---
description: 
globs: 
alwaysApply: true
---
Error Handling & Telemetry Integration in AppKit

Overview

Our goal is to improve error tracking in AppKit by proactively catching unhandled errors and sending them through telemetry. We want to refactor our controllers—each of which uses a Valtio state and a set of methods—to automatically catch errors, format them into a standard AppKitError, and send the details to our Pulse API.

Requirements
	•	Error Normalization: All errors must be wrapped in an AppKitError with one of the following categories:
	•	API_ERROR
	•	DATA_PARSING_ERROR
	•	SECURE_SITE_ERROR
	•	INTERNAL_SDK_ERROR
	•	Telemetry Reporting: Create a TelemetryController that formats error events and sends them via the Pulse API.
	•	Error Boundary Abstraction: Implement a generic abstraction that wraps controller methods, catching both synchronous and asynchronous errors.
	•	Data Privacy: Ensure that no customer-specific data is collected.

Proposed Implementation

1. Base Error Class (AppKitError)

This class defines the standard structure for errors in AppKit.

```
// AppKitError.ts
export enum AppKitErrorCategory {
  API_ERROR = 'API_ERROR',
  DATA_PARSING_ERROR = 'DATA_PARSING_ERROR',
  SECURE_SITE_ERROR = 'SECURE_SITE_ERROR',
  INTERNAL_SDK_ERROR = 'INTERNAL_SDK_ERROR'
}

export class AppKitError extends Error {
  public category: AppKitErrorCategory;
  public originalError: unknown;

  constructor(message: string, category: AppKitErrorCategory, originalError?: unknown) {
    super(message);
    this.name = 'AppKitError';
    this.category = category;
    this.originalError = originalError;
  }
}```


2. Telemetry Controller

This controller formats error events and logs (or sends) them to the Pulse API.
```
// TelemetryController.ts
import { AppKitError } from './AppKitError';

type ErrorEvent = {
  type: 'error';
  event: string; // One of the defined error categories
  properties: {
    errorType?: string; // e.g., "TypeError"
    errorMessage?: string;
    stackTrace?: string;
    uncaught?: boolean;
  }
};

export const TelemetryController = {
  sendError(error: AppKitError, uncaught = false) {
    const errorEvent: ErrorEvent = {
      type: 'error',
      event: error.category,
      properties: {
        errorType: error.name,
        errorMessage: error.message,
        stackTrace: error.stack,
        uncaught
      }
    };
    // Send errorEvent to the Pulse API (e.g., PulseAPI.sendEvent(errorEvent))
    console.log('Telemetry error event sent:', errorEvent);
  }
};```


3. Generic Error Boundary Abstraction

This helper wraps any controller methods to catch both synchronous and asynchronous errors.
```
// withErrorBoundary.ts (Simplified)
import { AppKitError, AppKitErrorCategory } from './AppKitError';
import { TelemetryController } from './TelemetryController';

export function withErrorBoundary<T extends Record<string, any>>(controller: T): T {
  const newController: Record<string, any> = {};
  Object.keys(controller).forEach((key) => {
    const original = controller[key];
    if (typeof original === 'function') {
      newController[key] = (...args: any[]) => {
        try {
          return original.apply(controller, args);
        } catch (err) {
          const error =
            err instanceof AppKitError
              ? err
              : new AppKitError(String(err), AppKitErrorCategory.INTERNAL_SDK_ERROR, err);
          TelemetryController.sendError(error);
          throw error;
        }
      };
    } else {
      newController[key] = original;
    }
  });
  return newController as T;
}
```

4. Refined Controller Example: SnackController

An example of a controller wrapped with the error boundary abstraction.
```
// SnackController.ts
import { proxy } from 'valtio/vanilla';
import { subscribeKey as subKey } from 'valtio/vanilla/utils';
import { CoreHelperUtil } from '../utils/CoreHelperUtil.js';
import { withErrorBoundary } from './withErrorBoundary';
import { AppKitErrorCategory } from './AppKitError';

// -- Constants ----------------------------------------- //
const DEFAULT_STATE = Object.freeze({
  message: '',
  variant: 'success',
  svg: undefined,
  open: false,
  autoClose: true
});

// -- Types --------------------------------------------- //
export interface SnackControllerState {
  message: string;
  variant: 'error' | 'success' | 'loading';
  svg?: { iconColor: string; icon: string };
  open: boolean;
  autoClose: boolean;
}

export type SnackControllerShowOptions = {
  autoClose?: boolean;
  svg?: SnackControllerState['svg'];
  variant?: SnackControllerState['variant'];
};

type StateKey = keyof SnackControllerState;

// -- State --------------------------------------------- //
const state = proxy<SnackControllerState>({
  ...DEFAULT_STATE
});

// -- Controller ---------------------------------------- //
const controller = {
  state,

  subscribeKey<K extends StateKey>(key: K, callback: (value: SnackControllerState[K]) => void) {
    return subKey(state, key, callback);
  },

  showLoading(message: SnackControllerState['message'], options: SnackControllerShowOptions = {}) {
    this._showMessage({ message, variant: 'loading', ...options });
  },

  showSuccess(message: SnackControllerState['message']) {
    this._showMessage({ message, variant: 'success' });
  },

  showSvg(message: SnackControllerState['message'], svg: NonNullable<SnackControllerState['svg']>) {
    this._showMessage({ message, svg });
  },

  showError(message: unknown) {
    const errorMessage = CoreHelperUtil.parseError(message);
    // Optionally, wrap this in an AppKitError before displaying.
    this._showMessage({ message: errorMessage, variant: 'error' });
  },

  hide() {
    state.message = DEFAULT_STATE.message;
    state.variant = DEFAULT_STATE.variant;
    state.svg = DEFAULT_STATE.svg;
    state.open = DEFAULT_STATE.open;
    state.autoClose = DEFAULT_STATE.autoClose;
  },

  _showMessage({
    message,
    svg,
    variant = 'success',
    autoClose = DEFAULT_STATE.autoClose
  }: { message: string } & SnackControllerShowOptions) {
    if (state.open) {
      state.open = false;
      setTimeout(() => {
        state.message = message;
        state.variant = variant;
        state.svg = svg;
        state.open = true;
        state.autoClose = autoClose;
      }, 150);
    } else {
      state.message = message;
      state.variant = variant;
      state.svg = svg;
      state.open = true;
      state.autoClose = autoClose;
    }
  }
};

// Export the controller wrapped with our error boundary.
export const SnackController = withErrorBoundary(controller);
```
